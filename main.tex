\documentclass{article}

% --- Packages ---
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{float}
\usepackage{booktabs}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{color,soul} 
\usepackage{amsmath}
\usepackage{geometry}
\usepackage{hyperref}
\usepackage{tikz}
\usetikzlibrary{shapes, arrows.meta, positioning, fit, backgrounds, calc}

% --- Page Setup ---
\geometry{a4paper, margin=1in}

% --- Metadata ---
\title{\textbf{Smart Intrusion Detection \& Access Control System}}
\author{Jenna Sorvoja, Jessica Suarez Cribillero, Fahad Ibne Fahian, Helinä Aura, Pinja Kamula}
\date{\today}

\begin{document}

\maketitle

\begin{center}
    \href{https://github.com/jsorv/IoT-group-12}{\textbf{Source Code on GitHub}}
\end{center}

\section{Introduction}
This project introduces the concept and implementation of a Smart Intrusion Detection and Access Control System based on the Raspberry Pi Pico W for motion sensing, secure remote authentication, and physical access control simulation. The system uses the End-to-End IoT architecture to process sensor data at the edge to determine the presence of unauthorized access, and communicates via the MQTT protocol to a custom web application.

Key features include: signal debouncing based on software, asynchronous multi-tasking to simultaneously run web and sensor tasks, and a logic-based security lockout mechanism. Intrusion detection and access control are important components of the modern smart security infrastructure, and the goal of the project is to design an IoT system that can be used to monitor secure zones for intrusion and remote access control. Typical use cases are small rooms, labs, or meeting spaces, where the system could be used to track occupancy and send alarms to users when a configurable capacity limit is exceeded.

\subsection{Functionalities}
The project implements the following major functionalities:

\begin{enumerate}
    \item \textbf{Sensor Data Collection:}

    The system continuously collects binary environmental data using a Passive Infrared (PIR) sensor connected to the GPIO pins of the Raspberry Pi Pico W. It detects infrared changes caused by human movement. The signal is digitally read and software-debounced to prevent false triggers.

    \item \textbf{Data Processing:}

    The Raspberry Pi Pico W serves as the edge computing node, responsible for several key functions. It filters sensor noise using a debouncing algorithm and processes incoming MQTT control messages for user PIN authentication.
    
    A state machine manages four system states:
    \begin{itemize}
        \item {Secure:} Idle monitoring (Door Locked, Blue LED).
        \item {Access Granted:} System unlocked (Green LED).
        \item {Alarm Activated:} Intrusion detected (Red LED).
        \item {Lockout:} System locked after three failed attempts (Yellow LED).
    \end{itemize}
    Authentication attempts are tracked, and if the threshold is exceeded, the system triggers an intrusion alarm and enters a lockout state. Motion event timestamps are debounced to prevent duplicate counts caused by sustained motion.

    \item \textbf{Output Control:}
    The system controls the following:
    \begin{itemize}
        \item A NeoPixel LED Strip (WS2812) provides comprehensive visual status feedback (e.g., Green for access granted, Red for intrusion).
        \item An active buzzer provides audible feedback: a short beep for motion detection, a welcome beep for successful access, and continuous alarm beeps for intrusion.
        \item An LCD display shows real-time system status.
        \item A local web dashboard displays system status via HTTPS.
    \end{itemize}
\end{enumerate}

\subsection{Advanced Functionalities}
Further, the project implements the following advanced functionalities:
\begin{enumerate}
    \item \textbf{Wireless Connectivity:}
    \begin{itemize}
        \item The Pico W connects to a local Wi-Fi network (2.4 GHz) using its onboard CYW43439 wireless chip.
        \item MQTT protocol is used for bidirectional communication between the device and cloud broker.
        \item The device publishes system status and alarm events to the \texttt{home/security/state} topic.
        \item The device subscribes to \texttt{home/security/cmd} to receive PIN commands and administrative controls from remote users.
    \end{itemize}
    
    \item \textbf{Custom Web App:}
    \begin{itemize}
        \item A custom web application developed using HTML and Tailwind CSS serves as the user interface. It connects directly to the MQTT broker to allow real-time monitoring and remote PIN code entry from any browser.
    \end{itemize}
    
    \item \textbf{Cloud Integration:}
    \begin{itemize}
        \item The system uses a cloud-based MQTT broker (HiveMQ Cloud) as the central message hub.
        \item The architecture supports integration with InfluxDB time-series database for persistent storage of motion events and alarm logs.
        \item Grafana dashboards can visualize historical patterns, peak entry times, and intrusion frequency.
    \end{itemize}
    
    \item \textbf{Security:}
    \begin{itemize}
        \item All MQTT communication is encrypted using TLS 1.2 (Transport Layer Security).
        \item The Pico W establishes an SSL context with the broker using the \texttt{ssl} module in MicroPython.
        \item User credentials (MQTT username/password) are stored in a separate \texttt{config.py} file excluded from version control.
        \item PIN authentication mechanism prevents unauthorized access; after 3 failed attempts, the system enters lockout mode requiring an admin \texttt{ADMIN\_RESET} command.
    \end{itemize}
\end{enumerate}

\subsection{Application Area}
The applicable areas of this system are perimeter security in smart buildings with special use in the case of University labs, small offices, and maker spaces. These environments can benefit from an inexpensive solution to intrusion detection and access control with Raspberry Pi Pico W to detect motion using the PIR sensor. The system also processes the data locally to ensure that the latency is kept to the minimum, sounding alarms and remote notifications whenever unauthorized motion is detected. Access control is managed via visual indicators (LEDs) and system state, which can be remotely controlled by a custom web application.

This solution makes use of MQTT to attain secure communication with the cloud to provide the real-time monitoring and events log functionality. The system creates a flexible and scalable way of secure zones i.e., zones can be efficiently monitored and controlled in different environments by combining edge processing with remote management.

\newpage

\section{Architecture}
The system follows a standard four-layer IoT architecture, ensuring separation of concerns between hardware control, networking, and data visualization.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{architecture_diagram.png}
    \caption{System Architecture Diagram}
    \label{fig:arch}
\end{figure}

\subsection{Sensing \& Actuation Layer}
The physical layer consists of the Raspberry Pi Pico W microcontroller (RP2040). It interfaces with:
\begin{itemize}
    \item{Input:} A PIR Motion Sensor (HC-SR501) connected to GPIO 7. It outputs a digital HIGH signal when infrared changes are detected.
    \item{Actuators:}
    \begin{itemize}
        \item A NeoPixel LED Strip (WS2812) connected to GPIO 16 serves as the primary visual output for lock state and alarms.
        \item A generic Buzzer connected to GPIO 5 provides immediate local feedback.
    \end{itemize}
    \item{Display:} A 16x2 LCD screen connected via the SoftI2C bus (GP2 SDA, GP3 SCL) provides on-site status information.
\end{itemize}

\subsection{Networking Layer}
The Networking Layer is responsible for reliable data transport. We utilized Wi-Fi (802.11n) provided by the Pico W's Infineon CYW43439 chip.
\begin{itemize}
    \item{Protocol:} We selected MQTT (Message Queuing Telemetry Transport) over HTTP. As discussed in the course lectures, MQTT is ideal for constrained IoT devices because its header size is small (min 2 bytes), and its publish/subscribe model allows the web app to receive ``push'' notifications instantly without battery-draining polling.
    \item{Broker:} We used HiveMQ Cloud, a public MQTT broker that supports SSL/TLS encryption, satisfying the security requirements of the project.
\end{itemize}

\subsection{Data Management Layer}
Data generated by the system (e.g., ``Motion Detected at 14:05'') is processed and stored.
\begin{itemize}
    \item{Middleware:} Node-RED running on a local server subscribes to the MQTT topics. It processes the raw JSON payloads from the Pico W.
    \item{Storage:} Processed data is written to InfluxDB, a time-series database optimized for timestamped sensor data (Data Warehouse model).
\end{itemize}

\subsection{Application Layer}
The user interacts with the system through two primary interfaces:
\begin{itemize}
    \item{Web App:} An HTML/Tailwind web app allows users to authenticate (Access Control) and send ``LOCK'' or ``UNLOCK'' commands via MQTT.
    \item{Dashboard:} A Grafana dashboard connects to InfluxDB to visualize intrusion frequency and system uptime.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{Web_App_Intrusion_Detection_System.png}
    \caption{Web App Interface}
    \label{fig:webapp}
\end{figure}

\section{Methods \& Tools}
The implementation relies on MicroPython firmware, leveraging specific libraries to handle concurrency and hardware control.

\subsection{Hardware Implementation}
The Raspberry Pi Pico W was selected as the low-level controller due to its native Wi-Fi support. The PIR sensor was chosen for motion detection because of its energy efficiency and privacy-preserving nature. The hardware was assembled on a breadboard to allow for modular testing. The connections were verified against the Pico W pinout diagram.
\begin{itemize}
    \item {PIR Sensor:} VCC to 5V (VBUS), GND to GND, Output to GP7.
    \item {NeoPixel LED:} VCC to 5V, GND to GND, Data to GP16.
    \item {LCD Display:} VCC to 5V (VBUS), GND to GND, SDA to GP2, SCL to GP3.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\textwidth]{wiring.jpg}
    \caption{Hardware Wiring Diagram}
    \label{fig:wiring}
\end{figure}

\subsection{Software \& Data Processing}
The firmware was developed in MicroPython using the Thonny IDE. To meet the complex Data Processing requirement, the software architecture was evolved from a simple linear loop to an asynchronous multitasking model using the \texttt{uasyncio} library.

\subsubsection{Asynchronous Multitasking}
The main program runs three concurrent tasks:
\begin{itemize}
    \item \texttt{sensor\_loop()}: Polls the PIR sensor and handles debouncing.
    \item \texttt{mqtt\_loop()}: Maintains the connection to the broker and checks for incoming messages.
    \item \texttt{web\_server()}: Listens for HTTP requests in non-blocking mode to display system status locally.
\end{itemize}

\subsubsection{MQTT Communication}
We used the \texttt{umqtt.simple} library. The system uses two topics:
\begin{itemize}
    \item \texttt{home/security/state}: The Pico publishes status updates here (e.g., \texttt{ARMED}, \texttt{DISARMED}).
    \item \texttt{home/security/cmd}: The Pico subscribes to this topic to receive remote commands like ``LOCK'' or ``UNLOCK''.
\end{itemize}

\subsubsection{Edge Logic Algorithms}
Two key algorithms are implemented directly on the microcontroller:

\paragraph{1. Signal Debouncing:}
To prevent false positives from the PIR sensor hardware, a time-based filter is applied. A motion event is registered only if:
\[ t_{current} - t_{last\_trigger} > 3.0 \text{ seconds} \]
This ensures that a single person walking past is counted as one event rather than multiple sensor spikes.

\paragraph{2. Security \& Lockout Logic:}
The system processes incoming MQTT payloads to verify credentials.
\begin{itemize}
    \item \textbf{Input:} Control commands received from the Web App.
    \item \textbf{Logic:} The code validates commands (\texttt{UNLOCK} vs \texttt{BAD\_PIN}).
    \item \textbf{State Machine Design:} The core logic relies on a finite state machine (FSM) to ensure predictable behavior.
    \begin{itemize}
        \item {State 0 (DISARMED):} The system ignores sensor inputs, and the system is unlocked (Green LED).
        \item {State 1 (ARMED):} The system actively polls the PIR sensor (Blue LED).
        \item {State 2 (ALERT):} Triggered by motion detection while in the ARMED state. The buzzer sounds, and alerts are sent to the cloud (Red LED).
        \item {Lockout Mode:} If \texttt{failed\_attempts} $\ge$ 3, the system enters a ``Lockout Mode,'' ignoring all input and sounding the buzzer for 60 seconds (Yellow LED).
    \end{itemize}
\end{itemize}

\subsection{Privacy \& Security Principles}
Following the principles from Lecture 11, we implemented:
\begin{itemize}
    \item{Data Minimization:} We only transmit status codes (Text), not sensitive audio or images.
    \item{Data Collection:} Our system collects binary environmental data using a Passive Infrared (PIR) sensor, which was chosen not only for its energy efficiency, but also for its privacy-preserving nature, as it does not capture any images.
    \item{Encryption:} All MQTT traffic is encrypted using SSL/TLS (port 8883) to prevent packet sniffing on the Wi-Fi network.
    \item{Access Control:} The Web App requires authentication before allowing the user to send ``UNLOCK'' commands, preventing unauthorized access.
\end{itemize}

\subsection{Reuse of Course Exercises}

\begin{itemize}
\item{Exercise 1:} MicroPython setup, GPIO configuration, I2C LCD driver integration.
\item{Exercise 2:} Wi-Fi connection logic, HTTP server implementation.
\item{Exercise 4-3:} MQTT publish-subscribe pattern, TLS setup, Node-RED integration for cloud-to-device control.
\item{Exercise 5:} InfluxDB and Grafana integration for data visualization (architecture supports this, though not fully deployed in final demo).
\end{itemize}

\subsection{Source Code}
The complete source code for the firmware, configurations, and the Web Application implementation is publicly available on GitHub: 
\begin{center}
    \textbf{\url{https://github.com/jsorv/IoT-group-12}}
\end{center}

\section{Evaluation}
To assess the performance and reliability of the implementation, we designed three specific evaluation scenarios focusing on reliability, latency, and logic validity.

\begin{itemize}
\item{System Reliability:} The percentage of actual physical events correctly registered by the system.
\item{System Latency:} The time delay (in milliseconds) between a user action (Web App) and system response (Visual Indicator).
\end{itemize}

\noindent
\textbf{Test Scenarios:}
\begin{itemize}
\item{Scenario A: Motion Detection Reliability.} A subject walked past the sensor at varying intervals (slow vs. rapid) to stress-test the debouncing logic.
\item{Scenario B: End-to-End Latency.} We measured the time elapsed between sending the correct PIN code from the Web App (via 4G) and the visual confirmation on the LED strip.
\item{Scenario C: Security Logic Verification.} An incorrect PIN was entered 3 consecutive times to verify if the edge logic correctly triggered the ``Lockout Mode'' and alarm.
\end{itemize}

\section{Results}

Numerical data collected from the test cases:

\begin{itemize}
\item{Scenario A (Reliability):} The system registered 19 out of 20 passes (95\% accuracy). The debouncing logic successfully filtered out noise during rapid movement, preventing double-counting.
\item{Scenario B (Latency):} The average latency for the remote unlock command was approximately 430 ms. The latency breakdown showed roughly 100ms for network transmission and 330ms for processing and display updates.
\item{Scenario C (Security):} The system successfully tracked failed attempts. Upon the 3rd incorrect entry, the buzzer activated immediately, and subsequent valid PINs were rejected until the lockout timer expired.
\end{itemize}

\subsection{Latency Measurements}

Table~\ref{tab:latency} shows latency results for both scenarios.

\begin{table}[h]
\centering
\begin{tabular}{lccc}
\toprule
\textbf{Metric} & \textbf{Scenario 1 (ms)} & \textbf{Scenario 2 (ms)} & \textbf{Target (ms)} \\
\midrule
Sensor-to-Publish & $85 \pm 15$ & $120 \pm 30$ & < 200 \\
Cmd-to-LED & $320 \pm 50$ & $450 \pm 80$ & < 500 \\
Web Request & $45 \pm 10$ & $60 \pm 20$ & < 100 \\
\bottomrule
\end{tabular}
\caption{System latency under low and high traffic conditions.}
\label{tab:latency}
\end{table}

\textbf{Observations:}
\begin{itemize}
\item All latencies meet target thresholds.
\item Sensor-to-Publish latency increases by ~40\% under high traffic due to MQTT queue processing.
\item Cmd-to-LED latency includes network roundtrip (device $\to$ broker $\to$ device) plus LED driver update time.
\end{itemize}

\subsection{Throughput Analysis}

Table~\ref{tab:throughput} summarizes message throughput.

\begin{table}[h]
\centering
\begin{tabular}{lcc}
\toprule
\textbf{Scenario} & \textbf{Outbound (msg/min)} & \textbf{Inbound (msg/min)} \\
\midrule
Scenario 1 (Low Traffic) & 6 & 2 \\
Scenario 2 (High Traffic) & 20 & 10 \\
\bottomrule
\end{tabular}
\caption{MQTT message throughput.}
\label{tab:throughput}
\end{table}

\textbf{Analysis:}
\begin{itemize}
\item In Scenario 1, debouncing limits motion events to 6/min (one every 10 seconds).
\item In Scenario 2, despite continuous PIR triggering, debouncing still enforces 3-second intervals, yielding ~20 events/min.
\item No message drops were observed in either scenario (confirmed via broker logs).
\end{itemize}

\subsection{Reliability Results}

\subsubsection{MQTT Reconnection}

\begin{itemize}
\item Broker was restarted at 60-second mark during a 5-minute test.
\item \texttt{umqtt.simple} (with custom retry logic) detected disconnection and attempted reconnection.
\item Connection restored in 8 seconds (after broker fully restarted).
\item \textbf{Result:} PASS — No manual intervention required.
\end{itemize}

\subsubsection{Wi-Fi Dropout}

\begin{itemize}
\item AP powered off at 90-second mark.
\item Pico W repeatedly called \texttt{wlan.connect()} in the connection loop.
\item Connection restored 5 seconds after AP came back online.
\item \textbf{Result:} PASS — Automatic recovery successful.
\end{itemize}

\subsubsection{Concurrent Task Performance}

To verify that the web server remains responsive during high MQTT traffic:
\begin{itemize}
\item In Scenario 2, HTTP requests to \texttt{/status} were sent every 2 seconds while processing 10 PIN commands.
\item All requests returned valid JSON within 60 ms.
\item \textbf{Result:} PASS — No task starvation; \texttt{uasyncio} scheduler effectively shares CPU time.
\end{itemize}

\newpage

\subsection{Functional Test Results}

Six functional tests were conducted, with results summarized in Table~\ref{tab:functional}.:

\begin{table}[h]
\centering
\small
\begin{tabular}{p{4cm}p{3cm}p{2cm}}
\toprule
\textbf{Test Case} & \textbf{Expected Outcome} & \textbf{Result} \\
\midrule
Motion Detection & Count increments, MQTT pub, LCD update & PASS \\
Valid PIN & Green LED, "Welcome" on LCD & PASS \\
Invalid PIN (1×) & "Wrong PIN" on LCD & PASS \\
Invalid PIN (3×) & Alarm triggered, lockout & PASS \\
Admin Unlock & Lockout cleared & PASS \\
Web Dashboard & Live status displayed & PASS \\
\bottomrule
\end{tabular}
\caption{Functional test results.}
\label{tab:functional}
\end{table}

\section{Discussion}

The project successfully met the goal of creating a functional, cloud-connected security system. The decision to use MQTT over HTTP was validated by the low-latency results in Scenario B; the persistent connection allowed for immediate alerts without the overhead of establishing a new handshake for every event.

The results demonstrate that the Smart Intrusion Detection \& Access Control System meets all functional requirements. The implementation of \textbf{uasyncio} was the critical success factor; it allowed the web server to remain responsive even while the system was processing sensor data and maintaining the MQTT connection. The reliability test (95\%) indicates that the PIR sensor is effective for indoor monitoring.

Future iterations could improve reliability by implementing a ``Store and Forward'' mechanism where data is cached locally on the Pico W during network outages and uploaded once connectivity is restored. Adding a camera module (ArduCam) for visual verification would also eliminate false positives from the PIR sensor.

\textbf{Strengths:}
The modular design allows for easy expansion (e.g., adding magnetic door sensors). The local LCD ensures that the system provides feedback even if the web app is not immediately available. The integration of Node-RED allows for powerful logic without modifying the firmware. The use of visual indicators (LEDs) instead of high-voltage motors reduces power consumption and risk of component burnout.

\textbf{Weaknesses:} A limitation observed was the PIR sensor's inability to detect direction (Entry vs. Exit). Additionally, the system currently relies on an active internet connection for the Web App to function.

\textbf{Context:} Compared to standard market solutions, this prototype offers a customizable and privacy-focused alternative that integrates multiple I/O peripherals into a single low-cost controller. This project provides a solid foundation for learning the principles of IoT and can be extended to a production-ready smart building security platform with additional features and hardening.

\end{document}